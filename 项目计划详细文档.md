# AIRP记忆系统：Graphiti集成详细项目计划

## 项目概述

### 1.1 项目背景
本项目旨在为SillyTavern AI角色扮演平台提供增强的记忆能力，通过集成Zep AI的Graphiti时序知识图谱框架，实现对角色心理状态、世界观逻辑和复杂事件关系的深度建模与推理。

### 1.2 核心需求
基于用户对话记录分析，系统需要解决以下关键问题：
1. **数据模式泛化问题**：适应不同角色卡的多样化实体关系定义
2. **输入格式解析问题**：处理SillyTavern的非结构化文本输入
3. **重复信息处理问题**：避免世界书等来源的内容重复记录
4. **动态更新与内容筛选问题**：智能区分和处理不同类型的内容

### 1.3 系统架构总览
```
┌─────────────────────────────┐
│     SillyTavern客户端       │
└──────────────┬──────────────┘
               │ OpenAI兼容API
               ▼
┌─────────────────────────────┐
│   API服务层 (FastAPI)        │
│  • 请求解析与分发           │
│  • Graphiti协调            │
│  • LLM调用管理              │
└──────────────┬──────────────┘
               │
    ┌──────────┼──────────┐
    ▼          ▼          ▼
┌─────────┐┌─────────┐┌─────────┐
│格式解析  │记忆管理  │ LLM服务  │
│模块     │模块     │模块     │
└─────────┘└─────────┘└─────────┘
               │
               ▼
┌─────────────────────────────┐
│   Graphiti时序知识图谱       │
│  • Neo4j存储后端            │
│  • 心理状态建模             │
│  • 因果逻辑推理             │
└─────────────────────────────┘
```

## 第二章：技术栈与基础设施

### 2.1 核心组件
- **数据库**: Neo4j 5.20社区版（时序知识图谱）
- **记忆框架**: Zep AI Graphiti（时序知识图谱记忆层）
- **API框架**: FastAPI + Uvicorn（高性能异步API）
- **LLM集成**: DeepSeek V3.2（通过OpenAI兼容API）
- **部署环境**: Docker Compose v2 + 容器化
- **编程语言**: Python 3.9+

### 2.2 环境要求

#### 硬件要求：
- **开发环境**：
  - CPU: 4核+
  - 内存: 8GB+（Neo4j至少4GB）
  - 存储: 50GB SSD
- **生产环境**：
  - CPU: 8核+
  - 内存: 16GB+（Neo4j 8GB）
  - 存储: 200GB NVMe SSD

#### 软件要求：
- Docker 20.10+ 和 Docker Compose v2.0+
- Python 3.9+
- pip 21.0+
- Git（版本控制）

### 2.3 目录结构
```
airp-memory-system/
├── docker-compose.yaml          # Docker编排文件
├── .env                         # 环境变量配置
├── README.md                    # 项目说明
├── neo4j/                       # Neo4j配置和数据
│   ├── data/                   # 数据持久化目录
│   ├── logs/                   # 日志目录
│   ├── import/                 # 初始数据导入
│   └── plugins/                # 插件目录
├── api-service/                 # API服务代码
│   ├── main.py                 # 应用入口
│   ├── Dockerfile              # 容器构建文件
│   ├── requirements.txt        # Python依赖
│   ├── config/                 # 配置文件
│   │   ├── __init__.py
│   │   ├── graphiti_config.py  # Graphiti配置
│   │   └── settings.py         # 应用设置
│   ├── services/               # 业务逻辑服务
│   │   ├── __init__.py
│   │   ├── graphiti_service.py # Graphiti服务
│   │   ├── llm_service.py      # LLM服务
│   │   └── parser_service.py   # 解析服务
│   ├── models/                 # 数据模型
│   │   ├── __init__.py
│   │   ├── entities.py         # 实体定义
│   │   └── relations.py        # 关系定义
│   ├── utils/                  # 工具工具
│   │   ├── __init__.py
│   │   ├── text_utils.py       # 文本处理工具
│   │   └── validation_utils.py # 验证工具
│   └── logs/                   # 应用日志
├── scripts/                    # 部署和维护脚本
│   ├── backup.sh              # 备份脚本
│   ├── restore.sh             # 恢复脚本
│   └── monitor.sh             # 监控脚本
└── docs/                       # 文档目录
    ├── api-reference.md       # API参考
    ├── deployment-guide.md    # 部署指南
    └── troubleshooting.md     # 故障排除
```

## 第三章：Graphiti数据模式设计

### 3.1 三层架构设计
基于对话记录分析，采用三层数据模式架构：

```
┌─────────────────────────────────────────┐
│         动态扩展层 (Dynamic Layer)      │
│  • 角色卡特定实体/关系                  │
│  • 运行时通过LLM分析创建                │
│  • 可持久化复用                        │
└────────────────────┬────────────────────┘
                     │
┌────────────────────▼────────────────────┐
│         通用适配层 (Adaptive Layer)     │
│  • 通用属性容器（垃圾桶属性）           │
│  • 灵活的关系映射                       │
│  • 临时实体存储                         │
└────────────────────┬────────────────────┘
                     │
┌────────────────────▼────────────────────┐
│         核心基础层 (Core Layer)         │
│  • 跨角色卡通用实体类型                 │
│  • 基础关系类型                         │
│  • 系统元数据                           │
└─────────────────────────────────────────┘
```

### 3.2 核心实体类型定义

#### 3.2.1 基础实体类
```python
# 伪代码表示设计思路
class CoreEntity:
    """所有实体的基类"""
    
    # 基本属性
    entity_id: UUID                    # 唯一标识
    entity_type: str                   # 实体类型
    name: str                          # 名称/标识符
    
    # 描述性属性
    description: Optional[str]         # 描述
    aliases: List[str]                 # 别名列表
    
    # 时间属性
    created_at: datetime               # 创建时间
    updated_at: datetime               # 更新时间
    valid_from: datetime               # 开始生效时间
    valid_until: Optional[datetime]    # 生效结束时间
    
    # 来源追踪
    source_references: List[SourceRef] # 来源引用
    confidence_score: float            # 置信度(0.0-1.0)
    
    # 元数据
    metadata: Dict[str, Any]           # 扩展元数据
    tags: List[str]                    # 标签分类
```

#### 3.2.2 具体实体类型
1. **Character（角色）**：
   - 核心属性：姓名、年龄、性别、外貌
   - 心理属性：性格特质、情绪状态、目标、恐惧
   - 关系属性：社会关系、所属组织、情感联系

2. **Location（地点）**：
   - 地理属性：坐标、区域、地形
   - 功能属性：建筑类型、设施、重要性
   - 关联属性：包含实体、连接地点

3. **Event（事件）**：
   - 时间属性：发生时间、持续时间
   - 参与属性：参与者、地点、物品
   - 因果属性：原因、结果、影响

4. **PsychologicalTrait（心理特质）**：
   - 类型属性：主导特质、次要特质、隐藏特质
   - 强度属性：表现强度、稳定性、可变性
   - 触发属性：激活条件、抑制条件

### 3.3 关系类型设计优化
采用**属性化关系模型**，仅定义几种基础关系类型，通过标签属性细分：

#### 3.3.1 基础关系类型（5种）
1. **HAS_RELATION_WITH**：社交关系基类
2. **HAS_ASSOCIATION_WITH**：关联关系基类
3. **HAS_TEMPORAL_ORDER**：时序关系基类
4. **HAS_CAUSAL_LINK**：因果关系基类
5. **HAS_SPATIAL_RELATION**：空间关系基类

#### 3.3.2 关系属性标签
```python
# 关系属性示例
relation_properties = {
    "relation_subtype": {
        "type": "string",
        "enum_values": ["friend", "lover", "enemy", "mentor", "family"],
        "allow_custom": True  # 允许自定义类型
    },
    "intensity": {
        "type": "float",
        "range": [0.0, 1.0],
        "default": 0.5
    },
    "confidence": {
        "type": "float", 
        "range": [0.0, 1.0],
        "default": 0.8
    },
    "context_tags": {
        "type": "array[string]",
        "examples": ["work", "personal", "romantic", "secret"]
    },
    "temporal_info": {
        "type": "object",
        "properties": {
            "start_time": "datetime",
            "end_time": "datetime",
            "duration": "timedelta"
        }
    }
}
```

### 3.4 通用属性容器设计
为处理未预定义数据，设计结构化通用属性容器：

```python
class UniversalPropertyContainer:
    """通用属性容器 - 存储未预定义或角色卡特定数据"""
    
    # 标准化部分
    property_type: str                    # 属性分类
    data_type: str                       # 数据类型
    value: Any                           # 实际值
    unit: Optional[str]                  # 单位
    
    # 来源与置信度
    source: SourceRef                    # 来源引用
    confidence: float                    # 置信度
    verification_status: str            # 验证状态
    
    # 上下文信息
    context: Dict[str, Any]              # 出现上下文
    constraints: List[str]               # 约束条件
    
    # 时间属性
    observed_at: List[datetime]          # 观测时间点
    valid_period: Optional[TimeInterval] # 有效时间区间
    
    # 关系信息
    dependencies: List[Condition]        # 依赖条件
    related_properties: List[PropertyRef] # 相关属性
```

## 第四章：输入解析与处理流程

### 4.1 SillyTavern输入格式分析
基于对话记录中的示例，SillyTavern输入包含多个部分：

#### 4.1.1 主要组成部分
1. **指令性内容**：
   - `<核心指导>`：创作准则和禁词表
   - `<基础风格>`：写作风格要求
   - `<创作准则>`：剧情和角色表现要求

2. **叙事性内容**：
   - `<相关资料>`：世界书、角色设定、地点信息
   - `<互动历史>`：对话上下文（User/Assistant交替）
   - `<补充资料>`：额外背景信息和创作指导

### 4.2 多级解析策略

#### 4.2.1 第一级：通用正则检测
```
正则表达式模式库：

1. 开标签检测：<([^/>]+)>
   - 匹配：<核心指导>、<补充资料>、<|User|>
   
2. 闭标签检测：</([^>]+)>
   - 匹配：</核心指导>、</互动历史>
   
3. 自闭合标签：<([^>]+)/>
   - 匹配：<br/>、<format/>

4. 特殊格式：
   - 竖线分隔：<|([^|]+)|>
   - 花括号：{{([^}]+)}}
   - 方括号双链：[[([^]]+)]] 
```

#### 4.2.2 第二级：启发式规则验证
当正则检测不完整时，应用启发式规则：

1. **对话历史识别**：
   - 交替出现"User:"和"Assistant:"模式
   - 包含角色名（如"Haruki:"）的对话格式

2. **世界书条目识别**：
   - 包含"地点("、"类别("、"概念("等模式
   - 结构化描述（列表、属性对、章节标题）

3. **角色描述识别**：
   - 包含"Character_Profile_of:"、"character:"等标识
   - 详细属性章节（appearance、personality、background）

#### 4.2.3 第三级：LLM辅助消歧（按需）
仅当规则无法确定时使用，通过提示词工程让LLM分析：

```
LLM分析提示词模板：

你是一个文本格式分析专家。请分析以下文本片段，识别其中的内容标签。

## 待分析文本
{text_fragment}

## 输出格式
{
  "detected_tags": [
    {
      "text": "<标签内容>",
      "type": "opening/closing/self-closing",
      "semantic_guess": "instruction/narrative/dialog",
      "confidence": 0.95
    }
  ]
}
```

### 4.3 并行处理架构

#### 4.3.1 通用工作线程池设计
```
动态任务分配系统：

┌─────────────────────────────────────┐
│         任务分发器                  │
│ • 接收所有待处理条目                │
│ • 维护负载均衡队列                  │
│ • 监控线程状态                      │
└──────────────┬──────────────────────┘
               │
    ┌──────────┼──────────┐
    ▼          ▼          ▼
┌─────────┐┌─────────┐┌─────────┐
│通用工作  │通用工作  │通用工作  │
│线程1    │线程2    │线程N    │
│任何条目 │任何条目 │任何条目 │
└─────────┘└─────────┘└─────────┘
    │          │          │
    └──────────┼──────────┘
               ▼
┌─────────────────────────────────────┐
│         结果收集器                  │
│ • 接收所有处理结果                  │
│ • 合并和排序                        │
└─────────────────────────────────────┘
```

#### 4.3.2 负载均衡策略
1. **任务窃取（Work Stealing）**：
   - 空闲线程从繁忙线程的任务队列窃取任务
   - 动态平衡各线程工作量

2. **优先级队列**：
   - 关键任务优先处理
   - 实时性要求高的任务优先

3. **批量处理**：
   - 相似任务批量执行
   - 减少上下文切换开销

## 第五章：重复信息处理机制

### 5.1 多层次去重系统

#### 5.1.1 第一层：快速文本指纹
```
MinHash + LSH算法：
1. 文本预处理：分词、去停用词、标准化
2. 生成MinHash签名：固定长度哈希表示
3. LSH分桶：相似文本分到相同桶
4. 快速比对：仅比对同桶内文本

优点：速度快、内存占用小
缺点：语义理解深度有限
```

#### 5.1.2 第二层：关键特征比对
```
特征提取维度：
1. 命名实体集合：人物、地点、组织等
2. 核心关系三元组：主-谓-宾
3. 数值和时间信息
4. 文本结构特征：段落、列表、标题

相似度计算：
总相似度 = w1×实体重叠率 + w2×关系相似度 + w3×结构相似度
```

#### 5.1.3 第三层：LLM语义判断（按需）
仅用于前两层无法确定的情况：

```
LLM语义分析提示词：

请判断以下两段文本是否描述相同或高度相似的内容。

## 文本A
{text_a}

## 文本B  
{text_b}

## 输出格式
{
  "is_similar": true/false,
  "similarity_score": 0.0-1.0,
  "overlap_type": "exact/paraphrase/partial/none",
  "reasoning": "判断理由"
}
```

### 5.2 实体合并策略

#### 5.2.1 合并决策树
```
开始实体合并检查
    │
    ▼
计算实体相似度
    ├── 相似度 > 0.9 ──→ 判定为同一实体，完全合并
    │
    ├── 相似度 > 0.7 ──→ 可能相同，建立关联关系
    │       │
    │       ▼
    │   标记需要验证
    │       │
    │       ▼
    │   人工审核或LLM确认
    │
    └── 相似度 < 0.7 ──→ 判定为不同实体，分别存储
```

#### 5.2.2 冲突解决规则
1. **时间优先**：更新信息覆盖旧信息
2. **置信度优先**：高置信度信息优先
3. **来源权威性**：权威来源信息优先
4. **一致性检查**：与现有知识的一致性

## 第六章：心理状态建模与演化跟踪

### 6.1 心理状态实体网络设计

#### 6.1.1 心理状态核心组件
```
心理状态建模体系：
    ┌─────────────────────────────────────┐
    │         Character (角色)            │
    └──────────────────┬──────────────────┘
                       │ HAS_PSYCHOLOGICAL_STATE
                       ▼
    ┌─────────────────────────────────────┐
    │    PsychologicalState (心理状态)     │
    │  • current_emotional_mix            │
    │  • dominant_emotion                 │
    │  • intensity_levels                 │
    │  • stability_score                  │
    │  • last_updated                     │
    └──────────────────┬──────────────────┘
                       │ COMPOSED_OF
          ┌────────────┼────────────┐
          ▼            ▼            ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│   EmotionNode   │ │   TraitNode     │ │  BeliefNode     │
│ • emotion_type  │ │ • trait_name    │ │ • belief_content│
│ • intensity     │ │ • strength      │ │ • confidence    │
│ • duration      │ │ • consistency   │ │ • origin        │
│ • triggers      │ │ • manifestations│ │ • implications  │
└─────────────────┘ └─────────────────┘ └─────────────────┘
```

#### 6.1.2 情绪状态建模
```python
class EmotionalState:
    """情绪状态实体"""
    
    # 基础情绪类型
    emotion_type: str  # "joy", "sadness", "anger", "fear", "surprise", "disgust"
    intensity: float   # 强度 0.0-1.0
    valence: float     # 效价（积极/消极） -1.0到1.0
    arousal: float     # 唤醒度 0.0-1.0
    
    # 时间属性
    onset_time: datetime        # 开始时间
    peak_time: Optional[datetime] # 峰值时间
    duration: timedelta         # 持续时间
    
    # 触发因素
    trigger_events: List[EventRef]    # 触发事件
    trigger_thoughts: List[str]      # 触发想法
    
    # 生理表现
    physiological_signs: List[str]    # 生理迹象
    behavioral_manifestations: List[str] # 行为表现
```

#### 6.1.3 性格特质建模
```python
class PersonalityTrait:
    """性格特质实体"""
    
    trait_name: str            # 特质名称
    trait_category: str        # 特质类别
    strength: float            # 强度 0.0-1.0
    stability: float           # 稳定性 0.0-1.0
    visibility: str           # "dominant"/"secondary"/"hidden"
    
    # 表现特征
    manifestations: List[str]  # 具体表现
    typical_contexts: List[str] # 典型情境
    
    # 影响因素
    genetic_component: Optional[float] # 遗传成分
    environmental_factors: List[str]   # 环境因素
    
    # 动态属性
    variability: float         # 可变性
    adaptability: float        # 适应性
```

### 6.2 心理状态演化跟踪机制

#### 6.2.1 状态转移模型
```
心理状态演化跟踪：
    当前状态 → 刺激事件 → 状态转移 → 新状态
    
状态转移规则：
    1. 情绪衰减：随时间自然衰减
       衰减率 = 基础衰减率 × (1 - 情绪强度 × 特质稳定性)
       
    2. 刺激响应：事件触发情绪变化
       变化量 = 事件强度 × 个体敏感性 × 情境调节因子
       
    3. 特质调节：性格特质调节响应强度
       调节因子 = 特质相关性 × 特质强度
       
    4. 记忆影响：过往经历影响当前反应
       影响权重 = 时间衰减因子 × 情感关联度
```

#### 6.2.2 演化跟踪数据结构
```python
class StateTransition:
    """状态转移记录"""
    
    # 转移信息
    from_state: PsychologicalStateRef  # 起始状态
    to_state: PsychologicalStateRef    # 目标状态
    transition_time: datetime          # 转移时间
    
    # 触发因素
    triggering_event: Optional[EventRef]  # 触发事件
    triggering_thought: Optional[str]     # 触发想法
    external_cause: Optional[str]        # 外部原因
    
    # 转移属性
    transition_type: str              # "emotion_shift"/"trait_expression"
    intensity_change: float           # 强度变化
    duration: timedelta               # 转移持续时间
    
    # 上下文信息
    context_tags: List[str]           # 情境标签
    influencing_factors: Dict[str, float]  # 影响因素及权重
```

#### 6.2.3 状态预测模型
```
心理状态预测流程：
    1. 当前状态分析：提取当前情绪和特质状态
    2. 环境因素评估：分析情境压力和刺激
    3. 历史模式匹配：查找相似历史情境
    4. 概率预测：计算各状态转移概率
    5. 置信度评估：评估预测可靠性
    
预测输出：
    • 最可能的下一个状态
    • 状态转移概率分布
    • 预测置信度得分
    • 关键影响因素列表
```

### 6.3 心理连贯性度量指标

#### 6.3.1 一致性评估体系
```
心理连贯性评估维度：

1. 特质一致性得分（0-100）
   - 跨时间特质表现的一致性
   - 计算公式：相似情境下特质表现的相关性
   
2. 情绪演化合理性得分（0-100）
   - 情绪变化的因果关系合理性
   - 情绪强度的变化符合心理规律
   
3. 行为模式一致性得分（0-100）
   - 行为与性格特质的匹配度
   - 行为与情绪状态的协调性
   
4. 记忆影响合理性得分（0-100）
   - 过往经历对当前影响的合理性
   - 记忆提取的上下文相关性
```

#### 6.3.2 连贯性监控算法
```
连贯性监控流程：

开始监控
    │
    ▼
收集当前状态数据
    │
    ▼
查询历史状态序列
    │
    ▼
计算一致性指标
    ├── 特质稳定性指数
    ├── 情绪连续性指数  
    ├── 行为一致性指数
    └── 记忆影响指数
    │
    ▼
加权综合评分
    │
    ▼
阈值判断与预警
    ├── 高连贯性（>80）：正常
    ├── 中连贯性（60-80）：关注
    └── 低连贯性（<60）：预警
```

## 第七章：世界观逻辑推演系统

### 7.1 因果逻辑链建模

#### 7.1.1 因果关系表示
```
因果链结构：
    ┌─────────────┐     CAUSES      ┌─────────────┐
    │   Cause     ├────────────────►│   Effect    │
    │   Event     │                 │   Event     │
    └─────────────┘                 └─────────────┘
           │                               │
           │ CONTRIBUTES_TO                │ LEADS_TO
           ▼                               ▼
    ┌─────────────┐                 ┌─────────────┐
    │ Contributing│                 │  Subsequent │
    │   Factor    │                 │   Event     │
    └─────────────┘                 └─────────────┘
```

#### 7.1.2 因果属性定义
```python
class CausalRelation:
    """因果关系实体"""
    
    # 基础信息
    cause_entity: EntityRef           # 原因实体
    effect_entity: EntityRef          # 结果实体
    relation_type: str                # "direct"/"indirect"/"conditional"
    
    # 强度属性
    causal_strength: float            # 因果强度 0.0-1.0
    temporal_proximity: float         # 时间接近度
    necessity_score: float            # 必要性得分
    sufficiency_score: float          # 充分性得分
    
    # 验证信息
    evidence_level: str              # "strong"/"moderate"/"weak"
    supporting_evidence: List[str]    # 支持证据
    counter_evidence: List[str]       # 反驳证据
    
    # 条件信息
    preconditions: List[Condition]    # 前提条件
    enabling_factors: List[FactorRef] # 促成因素
    inhibiting_factors: List[FactorRef] # 抑制因素
```

#### 7.1.3 因果链推理算法
```
因果推理流程：

开始推理
    │
    ▼
识别相关实体和事件
    │
    ▼
提取已知因果关系
    │
    ▼
构建因果网络图
    │
    ▼
执行推理操作：
    ├── 正向推理：已知原因预测结果
    ├── 反向推理：已知结果追溯原因
    ├── 反事实推理：假设情境推理
    └── 概率推理：不确定性推理
    │
    ▼
评估推理结果：
    ├── 置信度评分
    ├── 证据支持度
    └── 逻辑一致性
```

### 7.2 世界观规则建模

#### 7.2.1 规则表示系统
```
世界观规则格式：
    Rule: IF <conditions> THEN <consequences>
    
规则属性：
    • scope: 适用范围（全局/局部/临时）
    • exceptions: 例外情况列表
    • enforcement_level: 执行严格度
    • historical_precedents: 历史先例
    
规则示例：
    IF character is in_location("夏莱办公室") 
    AND time_of_day is "working_hours"
    THEN character can_access("所有学生档案")
    EXCEPT IF character.status is "suspended"
```

#### 7.2.2 规则推理引擎
```
规则推理流程：

输入：当前情境 + 适用规则集
    │
    ▼
规则匹配阶段：
    1. 提取情境特征
    2. 匹配规则条件
    3. 筛选适用规则
    │
    ▼
条件验证阶段：
    1. 验证前提条件
    2. 检查例外情况
    3. 评估约束条件
    │
    ▼
结果推导阶段：
    1. 应用规则逻辑
    2. 处理规则冲突
    3. 生成推导结果
    │
    ▼
置信度评估：
    1. 规则可靠性评分
    2. 情境匹配度评估
    3. 推导结果置信度
```

### 7.3 复杂事件推演机制

#### 7.3.1 事件推演框架
```
事件推演系统：

输入处理层：
    • 识别关键实体和关系
    • 提取适用规则和约束
    
推理计算层：
    • 构建事件发展图
    • 模拟可能发展路径
    • 评估各路径可能性
    
输出生成层：
    • 生成推演结果报告
    • 提供决策支持建议
    • 输出预测置信度
```

#### 7.3.2 推演算法设计
```
复杂事件推演流程：

1. 情境分析：
   - 提取当前状态特征
   - 识别关键影响因素
   
2. 规则提取：
   - 匹配适用世界观规则
   - 提取历史相似案例
   
3. 路径模拟：
   - 生成可能发展分支
   - 计算各分支概率
   
4. 冲突检测：
   - 检测逻辑矛盾
   - 验证时间一致性
   
5. 结果综合：
   - 加权整合推演结果
   - 评估预测可靠性
```

## 第八章：部署与运维配置

### 8.1 Docker Compose配置

#### 8.1.1 docker-compose.yaml
```yaml
version: '3.8'

services:
  neo4j:
    image: neo4j:5.20-community
    container_name: airp-neo4j
    restart: unless-stopped
    ports:
      - "7474:7474"      # HTTP浏览器端口
      - "7687:7687"      # Bolt协议端口
    environment:
      - NEO4J_AUTH=${NEO4J_USER}/${NEO4J_PASSWORD}
      - NEO4J_ACCEPT_LICENSE_AGREEMENT=yes
      - NEO4J_PLUGINS=["apoc", "graph-data-science"]
      - NEO4J_dbms_memory_pagecache_size=2G
      - NEO4J_dbms_memory_heap_initial__size=4G
      - NEO4J_dbms_memory_heap_max__size=4G
      - NEO4J_dbms_security_procedures_unrestricted=apoc.*,gds.*
      - NEO4J_dbms_logs_debug_level=INFO
    volumes:
      - ./neo4j/data:/data
      - ./neo4j/logs:/logs
      - ./neo4j/import:/var/lib/neo4j/import
      - ./neo4j/plugins:/plugins
    healthcheck:
      test: ["CMD", "cypher-shell", "-u", "${NEO4J_USER}", "-p", "${NEO4J_PASSWORD}", "RETURN 1"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - airp-network

  redis:
    image: redis:7-alpine
    container_name: airp-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    volumes:
      - ./redis/data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - airp-network

  api-service:
    build: ./api-service
    container_name: airp-api
    restart: unless-stopped
    ports:
      - "8000:8000"
    environment:
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=${NEO4J_USER}
      - NEO4J_PASSWORD=${NEO4J_PASSWORD}
      - REDIS_URL=redis://redis:6379
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - DEEPSEEK_API_KEY=${DEEPSEEK_API_KEY}
      - DEEPSEEK_BASE_URL=${DEEPSEEK_BASE_URL}
      - API_HOST=0.0.0.0
      - API_PORT=8000
      - API_WORKERS=4
      - LOG_LEVEL=info
      - APP_ENV=${APP_ENV}
      - APP_DEBUG=${APP_DEBUG}
    volumes:
      - ./api-service:/app
      - ./logs/api:/app/logs
    depends_on:
      neo4j:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - airp-network

networks:
  airp-network:
    driver: bridge

volumes:
  neo4j_data:
  redis_data:
```

#### 8.1.2 .env环境变量文件
```env
# 应用环境配置
APP_ENV=development
APP_DEBUG=true
APP_SECRET_KEY=your_secure_secret_key_here

# Neo4j数据库配置
NEO4J_USER=neo4j
NEO4J_PASSWORD=your_secure_password_here

# Redis缓存配置
REDIS_PASSWORD=your_redis_password_here

# DeepSeek API配置
DEEPSEEK_API_KEY=your_deepseek_api_key_here
DEEPSEEK_BASE_URL=https://api.deepseek.com

# 服务配置
API_HOST=0.0.0.0
API_PORT=8000
API_WORKERS=4
LOG_LEVEL=info

# Graphiti配置
GRAPHITI_CACHE_TTL=3600
GRAPHITI_MAX_RETRIES=3
GRAPHITI_TIMEOUT=30
GRAPHITI_MAX_ENTITIES_PER_CHUNK=50
GRAPHITI_MIN_CONFIDENCE=0.7
```

### 8.2 API服务Dockerfile配置

#### 8.2.1 api-service/Dockerfile
```dockerfile
FROM python:3.9-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    curl \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .

# 安装Python依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建日志目录
RUN mkdir -p /app/logs

# 创建非root用户
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# 启动命令
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "4"]
```

#### 8.2.2 api-service/requirements.txt
```txt
# Web框架
fastapi==0.104.1
uvicorn[standard]==0.24.0
python-multipart==0.0.6

# Neo4j驱动
neo4j==5.19.0

# Graphiti相关
zep-ai>=0.8.0  # 包含graphiti模块
pydantic>=2.5.0
pydantic-settings>=2.1.0

# LLM集成
openai>=1.3.0  # 使用OpenAI兼容API
httpx>=0.25.0

# 文本处理
nltk>=3.8.1
spacy>=3.7.0

# 缓存
redis>=5.0.0

# 工具库
pytz>=2023.3
python-dateutil>=2.8.2
numpy>=1.24.0

# 开发工具
pytest>=7.4.0
pytest-asyncio>=0.21.0
black>=23.11.0
flake8>=6.1.0
```

### 8.3 部署步骤与验证

#### 8.3.1 环境准备步骤
```
部署流程：

1. 创建项目目录
   mkdir -p /opt/airp-memory-system
   cd /opt/airp-memory-system

2. 复制配置文件
   • docker-compose.yaml
   • .env (根据实际环境配置)
   • 创建必要的子目录

3. 创建目录结构
   mkdir -p neo4j/{data,logs,import,plugins}
   mkdir -p redis/data
   mkdir -p logs/api
   mkdir -p api-service/{config,services,models,utils,logs}

4. 配置环境变量
   vi .env
   # 根据实际环境修改配置


5. 启动服务
   docker-compose up -d

6. 验证服务
   # 检查服务状态
   docker-compose ps

   # 检查Neo4j连接
   curl http://localhost:7474

   # 检查API健康状态
   curl http://localhost:8000/health

   # 测试OpenAI兼容端点
   curl -X POST "http://localhost:8000/v1/chat/completions" \
     -H "Content-Type: application/json" \
     -d '{
       "model": "deepseek-v3.2",
       "messages": [
         {"role": "user", "content": "Hello"}
       ],
       "temperature": 0.7
     }'
```
```

#### 8.3.2 启动脚本示例
创建启动脚本 `scripts/start.sh`:

```bash
#!/bin/bash

# AIRP记忆系统启动脚本

set -e

echo "=== AIRP记忆系统启动 ==="
echo "开始时间: $(date)"

# 检查Docker和Docker Compose
if ! command -v docker &> /dev/null; then
    echo "错误: Docker未安装"
    exit 1
fi

if ! command -v docker-compose &> /dev/null; then
    echo "错误: Docker Compose未安装"
    exit 1
fi

# 检查环境变量文件
if [ ! -f ".env" ]; then
    echo "警告: .env文件不存在，使用示例配置"
    cp .env.example .env
    echo "请编辑 .env 文件配置实际参数"
    exit 1
fi

# 创建必要目录
echo "创建目录结构..."
mkdir -p neo4j/{data,logs,import,plugins}
mkdir -p redis/data
mkdir -p logs/api

# 设置权限
chmod 600 .env
chmod 755 scripts/*.sh

# 启动服务
echo "启动服务..."
docker-compose up -d --build

# 等待服务启动
echo "等待服务启动..."
sleep 10

# 验证服务状态
echo "检查服务状态..."
docker-compose ps

# 测试连接
echo "测试API健康检查..."
curl -f http://localhost:8000/health || {
    echo "API健康检查失败"
    docker-compose logs api-service
    exit 1
}

echo "测试OpenAI兼容端点..."
curl -X POST "http://localhost:8000/v1/chat/completions" \
  -H "Content-Type: application/json" \
  -d '{
    "model": "deepseek-v3.2",
    "messages": [
      {"role": "user", "content": "Hello, are you working?"}
    ],
    "temperature": 0.7
  }' || {
    echo "OpenAI兼容端点测试失败"
    exit 1
}

echo "=== 启动完成 ==="
echo "服务已成功启动:"
echo "• Neo4j浏览器: http://localhost:7474"
echo "• API服务: http://localhost:8000"
echo "• 健康检查: http://localhost:8000/health"
echo "完成时间: $(date)"
```

## 第九章：SillyTavern配置与集成

### 9.1 SillyTavern连接配置

#### 9.1.1 OpenAI兼容连接设置
在SillyTavern界面中配置:

1. **进入连接设置**
   - 点击设置 → 连接
   - 选择"OpenAI"作为API类型

2. **API端点配置**
   ```
   API URL: http://你的服务器IP:8000/v1/chat/completions
   API Key: 任意值 (我们的API不验证此key，但SillyTavern需要填写)



3. **模型配置**
   ```
   模型名称: deepseek-v3.2

   （这将被映射到我们API中的模型名）


4. **上下文设置**
   - 启用"发送世界信息"

   - 启用"发送角色定义"

   - 上下文长度: 8192 (推荐)



#### 9.1.2 自定义请求格式
如果需要自定义请求格式，可以在 `api-service/config/settings.py` 中配置:

```python
class SillyTavernConfig:
    """SillyTavern特定配置"""

    # 请求格式模板
    request_template = {
        "model": "{model}",
        "messages": [
            {
                "role": "system",

                "content": "你是一个AI角色扮演助手，使用以下上下文进行创作。"

            },

            {
                "role": "user",

                "content": "{enhanced_context}"

            }

        ],
        "temperature": 0.7,

        "max_tokens": 2000,

        "stream": False

    }


    # 响应解析配置

    response_parsing = {

        "content_field": "choices[0].message.content",

        "usage_field": "usage",

        "error_field": "error"

    }
```

### 9.2 会话管理与隔离

#### 9.2.1 会话ID生成策略
```
会话ID生成规则:

1. 从SillyTavern请求中提取:
   • 自定义头部: X-Session-ID
   • 请求参数: session_id
   • 用户标识: user_id

2. 如果无法提取，生成新的会话ID:
   格式: sess-{uuid}-{timestamp}


3. 会话ID用于:
   • 在Graphiti中隔离不同对话的记忆

   • 支持多用户并发

   • 支持会话恢复
```

#### 9.2.2 会话数据生命周期
```
会话数据管理:

1. 会话创建:
   • 新会话开始时创建会话记录

   • 初始化会话元数据

2. 会话更新:

   • 每次交互更新会话数据

   • 记录交互时间和内容


3. 会话结束:

   • 手动结束或超时自动结束



   • 归档历史会话数据
```

## 第十章：测试与验证

### 10.1 功能测试用例

#### 10.1.1 输入解析测试
```
测试用例1: 标准SillyTavern格式解析

输入: 包含<核心指导>、<相关资料>、<互动历史>的完整提示词

预期结果:

    • 正确识别所有标签

    • 正确分类指令性和叙事性内容

    • 成功提取实体和关系
```

#### 10.1.2 记忆存储测试
```
测试用例2: 实体关系存储



输入: 包含多个角色、地点、事件的叙述



预期结果:



    • 成功提取所有实体



    • 正确建立实体关系



    • 数据成功存储到Graphiti
```

#### 10.1.3 记忆检索测试
```
测试用例3: 相关记忆检索



输入: 当前对话上下文



预期结果:



    • 成功检索相关历史记忆



    • 检索结果按相关性排序



    • 返回结构化的记忆信息
```

### 10.2 性能测试

#### 10.2.1 响应时间测试
```
性能指标:



    • 平均响应时间: < 2秒



    • P95响应时间: < 5秒



    • 最大响应时间: < 10秒
```

#### 10.2.2 并发测试
```
并发能力:



    • 支持并发用户数: ≥ 10



    • 峰值处理能力: ≥ 20请求/秒



    • 系统稳定性: 7×24小时无故障运行
```

## 第十一章：维护与监控

### 11.1 监控配置

#### 11.1.1 健康检查端点
```python
# 在main.py中添加
@app.get("/metrics")
async def metrics():
    """Prometheus指标端点"""
    return {
        "system_status": "healthy",
        "memory_usage": get_memory_usage(),
        "cpu_usage": get_cpu_usage(),
        "active_sessions": count_active_sessions(),
        "total_entities": count_total_entities(),
        "requests_per_minute": count_requests_per_minute()
    }
```

#### 11.1.2 日志配置
```python
# 日志配置文件 logging_config.py
import logging
from logging.handlers import RotatingFileHandler
import sys

def setup_logging():
    """
    配置日志系统
    """
    
    # 日志格式
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # 控制台处理器
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    console_handler.setLevel(logging.INFO)
    
    # 文件处理器
    file_handler = RotatingFileHandler(
        '/app/logs/airp-memory-system.log',
        maxBytes=10485760,  # 10MB
        backupCount=5
    )
    file_handler.setFormatter(formatter)
    file_handler.setLevel(logging.DEBUG)
    
    # 根日志器配置
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.DEBUG)
    root_logger.addHandler(console_handler)
    root_logger.addHandler(file_handler)
```

### 11.2 备份与恢复

#### 11.2.1 备份脚本
创建 `scripts/backup.sh`:

```bash
#!/bin/bash

# AIRP记忆系统备份脚本

set -e

BACKUP_DIR="/backups/airp-memory-system"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_PATH="${BACKUP_DIR}/backup_${DATE}"

echo "=== 开始备份 AIRP记忆系统 ==="
echo "备份时间: $(date)"
echo "备份路径: ${BACKUP_PATH}"

# 创建备份目录
mkdir -p "${BACKUP_PATH}"

# 备份Neo4j数据库
echo "备份 Neo4j 数据库..."
docker exec airp-neo4j neo4j-admin dump --database=neo4j --to=/backups/neo4j_${DATE}.dump
cp neo4j/data/* "${BACKUP_PATH}/neo4j/" 2>/dev/null || true

# 备份Redis数据（如果启用）
if [ -d "redis/data" ]; then
    echo "备份 Redis 数据..."
    cp -r redis/data "${BACKUP_PATH}/redis/"
fi

# 备份应用日志
echo "备份应用日志..."
cp -r logs "${BACKUP_PATH}/"

# 备份配置文件
echo "备份配置文件..."
cp docker-compose.yaml "${BACKUP_PATH}/"
cp .env "${BACKUP_PATH}/"
cp -r api-service/config "${BACKUP_PATH}/config/"

# 创建备份清单
echo "创建备份清单..."
cat > "${BACKUP_PATH}/backup_manifest.txt" << EOF
备份信息:
  时间: $(date)
  系统: AIRP记忆系统
  版本: 1.0.0

包含内容:
  1. Neo4j数据库快照
  2. Redis数据(如果启用)
  3. 应用日志
  4. 配置文件
  5. 配置目录

备份完成时间: $(date)
EOF

# 压缩备份
echo "压缩备份文件..."
cd "${BACKUP_DIR}"
tar -czf "backup_${DATE}.tar.gz" "backup_${DATE}"
rm -rf "backup_${DATE}"

echo "=== 备份完成 ==="
echo "备份文件: ${BACKUP_DIR}/backup_${DATE}.tar.gz"
echo "备份大小: $(du -h "${BACKUP_DIR}/backup_${DATE}.tar.gz" | cut -f1)"
echo "备份时间: $(date)"
```

## 第十二章：扩展与优化路线图

### 12.1 短期优化（1-3个月）

#### 12.1.1 性能优化
```
短期优化目标:



   1. 查询缓存优化



   2. 并行处理改进



   3. 内存使用优化



   4. 响应时间改进
```

#### 12.1.2 功能增强
```
功能扩展:



   1. 情感分析集成



   2. 图像记忆支持



   3. 多语言处理增强
```

### 12.2 中期发展（3-6个月）

#### 12.2.1 系统扩展
```
中期目标:



   1. 分布式部署支持



   2. 高可用性架构



   3. 负载均衡优化



   4. 数据分片策略
```

#### 12.2.2 功能深化
```
功能深化:



   1. 高级心理建模



   2. 复杂事件推演



   3. 智能记忆管理



   4. 自适应学习机制
```

### 12.3 长期规划（6-12个月）

#### 12.3.1 系统演进
```
长期发展方向:



   1. 人工智能融合



   2. 多模态记忆支持



   3. 自适应架构



   4. 智能优化系统
```

## 总结

### 项目价值
本项目通过集成Graphiti时序知识图谱框架，为SillyTavern角色扮演平台提供了深度记忆能力，实现了：

1. **心理连贯性建模**：跟踪角色心理状态演化，确保角色行为一致性
2. **世界观逻辑推演**：建立因果链和规则系统，支持复杂事件推理
3. **动态知识管理**：智能处理重复信息，支持内容实时更新
4. **高效记忆检索**：快速访问相关记忆，增强角色扮演体验

### 技术特色
1. **三层数据模式架构**：核心层 + 适配层 + 动态扩展层
2. **属性化关系模型**：有限基础关系类型 + 无限属性标签
3. **多级解析策略**：正则检测 + 启发式规则 + LLM辅助
4. **并行处理系统**：动态负载均衡 + 通用工作线程池

### 实施建议
1. **分阶段实施**：按照项目计划分阶段完成开发部署
2. **渐进式优化**：先确保核心功能，再逐步优化完善
3. **持续监控**：建立完善的监控和维护体系
4. **用户反馈**：根据实际使用情况持续改进系统

本详细项目计划提供了从架构设计到部署运维的完整解决方案，为AIRP记忆系统的开发实施提供了全面的技术指导和实践路径。通过本计划的执行，将构建一个功能强大、性能优越、易于维护的记忆增强系统，显著提升SillyTavern角色扮演的用户体验和创作质量。

---
*文档版本: 1.0.0*
*最后更新: 2026年1月3日*
*文档状态: 完成*
